{
  description = "mongo";

  inputs = {
    nixpkgs = {
      url = "github:NixOS/nixpkgs/master";
      # This needs to follow the `nixpkgs` from nativelink so that the local LRE
      # toolchains are in sync with the remote toolchains.
      follows = "nativelink/nixpkgs";
    };
    flake-utils.url = "github:numtide/flake-utils";
    flake-parts = {
      url = "github:hercules-ci/flake-parts";
      inputs.nixpkgs-lib.follows = "nixpkgs";
    };
    pre-commit-hooks = {
      url = "github:cachix/pre-commit-hooks.nix";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    nativelink = {
      # Note: Keep this commit in sync with the LRE commit in `MODULE.bazel`.
      url = "github:TraceMachina/nativelink/03841cc340816058363d7a2958d0dbc31113c1de";

      # This repository provides the autogenerated LRE toolchains which are
      # dependent on the nixpkgs version in the nativelink repository. To keep
      # the local LRE toolchains aligned with remote LRE, we need to use the
      # nixpkgs used by nativelink as the the "global" nixpkgs. We do this by
      # setting `nixpkgs.follows = "nativelink/nixpkgs"` above.

      inputs = {
        flake-utils.follows = "flake-utils";
        flake-parts.follows = "flake-parts";
        git-hooks.follows = "pre-commit-hooks";
      };
    };
    nix2container = {
      follows = "nativelink/nix2container";
    };
  };

  outputs = inputs @ {
    self,
    flake-parts,
    nativelink,
    nix2container,
    ...
  }:
    flake-parts.lib.mkFlake {inherit inputs;} {
      systems = [
        "x86_64-linux"
        "x86_64-darwin"
        "aarch64-darwin"
      ];
      imports = [
        inputs.nativelink.flakeModule
      ];
      perSystem = {
        config,
        pkgs,
        system,
        ...
      }: let
        inherit (inputs.nativelink.packages.${system}) native-cli lre-cc nativelink-debug;
        inherit (nix2container.packages.${system}.nix2container) buildImage;

        llvmPackages = pkgs.llvmPackages_18;

        customStdenv = import ./tools/llvmStdenv.nix {inherit pkgs llvmPackages;};

        # TODO(aaronmondal): This doesn't work with rules_rust yet.
        # Tracked in https://github.com/TraceMachina/nativelink/issues/477.
        customClang = pkgs.callPackage ./tools/customClang.nix {
          inherit pkgs;
          stdenv = customStdenv;
        };

      in {
        local-remote-execution.settings = {
          Env =
            if pkgs.stdenv.isDarwin
            then [] # Doesn't support Darwin yet.
            else lre-cc.meta.Env;
          prefix = "lre";
        };
        devShells.default = pkgs.mkShell {
          nativeBuildInputs = let
            bazel = pkgs.writeShellScriptBin "bazel" ''
              unset TMPDIR TMP
              exec ${pkgs.bazelisk}/bin/bazelisk "$@"
            '';
          in
            [
              # Development tooling goes here.
              bazel
              pkgs.poetry

              # Additional tools from within our development environment.
              customClang
            ];
          shellHook = ''
            # Generate .bazelrc.lre which configures the LRE toolchains.
            ${config.local-remote-execution.installationScript}

            # The Bazel and Cargo builds in nix require a Clang toolchain.
            # TODO(aaronmondal): The Bazel build currently uses the
            #                    irreproducible host C++ toolchain. Provide
            #                    this toolchain via nix for bitwise identical
            #                    binaries across machines.
            export CC=clang
          '';
        };
      };
    };
}
